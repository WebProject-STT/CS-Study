# CPU 스케줄링
- CPU 스케줄링은 다중 프로그램 운영체제의 기본
<pre><code>💡 스레드를 지원하는 운영체제에서는 실질적으로 운영체제는 프로세스가 아닌 커널 수준 스레드를 스케줄함</pre></code>

## CPU 스케줄링의 기본 개념
1. 다중 프로그래밍의 목적은 계속 프로세스에게 CPU를 할당시켜 CPU 이용률을 최대화하는 것
2. 실행중이던 프로세스가 입출력 완료 같은 사건을 기다릴 경우, 운영체제는 CPU를 회수해 메모리에 적재돼있던 다른 프로세스에게 CPU 할당시킴
3. CPU 스케줄링은 운영체제 설계의 `핵심`

## CPU-입출력 버스트 사이클(CPU-I/O Burst Cycle)
1. 프로세스 실행은 CPU 버스트와 입출력 버스트의 사이클로 구성됨         
    <pre><code>💡 CPU burst: 프로세스가 CPU를 사용하는 구간, 입출력 burst: 프로세스가 I/O 완료를 기다리는 구간</pre></code>
2. 프로세스들은 이들 두 상태 사이를 교대로 왔다갔다함
3. 마지막 CPU 버스트 후에 입출력 버스트가 발생하지만, 실행 종료 위한 시스템 요청과 함께 끝남
4. CPU 버스트들의 지속 시간을 측정한 결과, 유사한 빈도수 곡선을 갖는 것을 확인      
    - 이 곡선은 지수형, 초지수형으로 나뉨
    - 짧은 CPU 버스트가 많고, 긴 CPU 버스트는 적음
5. I/O 중심 프로그램은 짧은 CPU 버스트를 많이 가지고, CPU 중심 프로그램은 긴 CPU 버스트를 많이 가질 것      
    ➡ 이러한 특성은 CPU 스케줄링 알고리즘을 선택하는데 매우 중요한 요소

    <img src="./image/cpu_io_burst.PNG" alt="cpu_io_burst" width="250" style="max-width:100%"/>     

    ➡ CPU와 입출력 버스트(burst)의 교차        

    <img src="./image/histogram_cpu_burst_durations.PNG" alt="histogram_cpu_burst_durations" width="400" style="max-width:100%"/>       

    ➡ CPU 버스트 시간의 도표

### CPU 스케줄러(CPU Scheduler)
1. CPU 스케줄러(단기 스케줄러): Ready Queue에 적재된 프로세스들 중 하나를 선택해 CPU 할당
2. CPU가 쉴 때마다 CPU 스케줄러가 일함
3. Ready Queue는 반드시 큐(FIFO 방식)가 아니어도 됨     
    ➡ 선입선출 큐, 우선순위 큐, 트리, 연결 리스트로 구현될 수 있음
4. 큐에 있는 레코드들은 일반적으로 프로세스들의 PCB들임

    <img src="./image/ready_queue.PNG" alt="ready_queue" width="500" style="max-width:100%"/>       
    
    ➡ Ready Queue

### CPU 스케줄링 종류
1. CPU 스케줄링이 발생하는 상황
    - 프로세스가 실행 상태에서 대기 상태로 전환될 때 🛠`비선점`     
        ➡ I/O 요청이나 자식 프로세스 종료 기다리려고 wait() 호출할 때 
    - 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때 🛠`선점`      
        ➡ 인터럽트 발생        
        <pre><code>💡 인터럽트: 프로그램을 실행하는 도중에 예기치 않은(CPU의 점유를 빼앗기는) 상황이 발생할 경우 작업을 즉시 중단하고, 발생된 상황을 우선 처리한 후 실행중이던 작업으로 복귀하여 처리하는 것</pre></code>
    - 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때 🛠`선점`    
        ➡ 입출력 종료 시
    - 프로세스 종료할 때 🛠`비선점`
2. 비선점 스케줄링(Non-Preemptive Scheduling) or 협조적(Cooperative) 스케줄링
    - 이미 특정 프로세스에게 할당된 CPU를 다른 프로세스가 강제로 빼앗을 수 없음
    - CPU가 한 프로세스에게 할당되면, 프로세스가 종료하거나 대기 상태로 전환해 CPU를 반환할 때까지 CPU 점유     
        ➡ ❗인터럽트 허용되지 않음❗
    - 모든 프로세스에 대해 공정하게 처리할 수 있음
    - 일괄 처리 방식에 적합, 중요한 작업이 기다리는 경우가 발생할 수 있음
    - 수행기간이 긴 프로세스가 자원을 점유하게 되면 이후에 실행 될 프로세스들이 기아(starvation) 상태에 빠지게 됨
        <pre><code>💡 기아(starvation) 상태: 프로세스가 원하는 자원을 계속 할당받지 못하는 상태</pre></code>
 
3. 선점 스케줄링(Preemptive Scheduling)
    - 특정 프로세스에게 할당된 CPU를 다른 우선순위가 높은 프로세스가 강제로 빼앗을 수 있음
    - 프로세스는 한번 실행될 때 `제한된 시간을 할당`받고 시간이 지나면 CPU 반환       
        ➡ ❗인터럽트 허용됨❗
    - 우선순위가 높은 프로세스를 빠르게 처리할 수 있음
    - 빠른 응답시간을 요구하는 대화식 시분할 시스템에 이용
    - 선점으로 인한 많은 오버헤드 초래
    - 여러 프로세스가 자원을 공유할 경우 경쟁 조건을 초래할 수 있음
        <pre><code>💡 경쟁 조건(Race Condition): 다중 프로세스 환경에서 두개 이상의 프로세스가 동시에 수행될 때 발생되는 비정상적인 상태</pre></code>
4. 인터럽트에 의해 영향 받는 코드 부분은 동시 사용으로부터 보호돼야 함
    - 해당 부분은 여러 프로세스가 동시에 접근할 수 없도록 해야함 
    - 진입점에서 인터럽트 불능화하고 출구에서 가능화하도록 해야함       
        ➡ ❗인터럽트 불능화는 자주 발생해선 안됨, 아주 적은 수의 명령어들만 포함해야 함

### 디스패처(Dispatcher)
1. CPU 스케줄링 = 프로세스 선택(Scheduling) + 선택된 프로세스 CPU에 올림(Dispatch)
2. 디스패처: `CPU의 제어`를 CPU 스케줄러가 선택한 프로세스에게 주는 `모듈`
3. 디스패처가 하는 일
    - Context Switch
    - 사용자 모드로 전환
    - 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동(jump)하는 일
4. 디스패처는 모든 프로세스의 Context Switch시 호출     
    ➡ 수행 시간이 짧아야 함
5. 디스패치 지연(Dispatch Latency): 디스패치가 하나의 프로세스를 정지하고 다른 프로세스의 수행을 시작하는 데까지 소요되는 시간

## 스케줄링 기준(Scheduling Criteria)
스케줄링 알고리즘을 평가하는 기준
1. CPU 이용률(Utilization)
    - CPU가 얼마나 많이 사용되고 있는지!
2. 처리량(Throughput)
    - 단위 시간당(주어진 시간동안) 수행 완료된 프로세스의 개수
3. 총처리 시간(Turnaround Time)
    - 프로세스를 실행하는데 소요된 시간 = 메모리에 들어가기 위해 기다린 시간 + Ready Queue에서 대기한 시간 + CPU에서 실행한 시간 + 입출력 시간
4. 대기 시간(Waiting Time)
    - Ready Queue에서 대기하며 보낸 시간
    - `다른 프로세스 때문`에 `대기`한 시간
    - 해당 프로세스의 실행 시간이나 입출력 시간 같은 것들은 포함하지 않음       
        ➡ 내가 요청하고 실행한거니까!
5. 응답 시간(Response Time)
    - 대화식 시스템에서 응답이 시작되는데 걸린 시간     
        <pre>🖥️ 응답 시간의 예시   
        1. 사용자가 아주 큰 파일 압축을 요청        
        2. 압축하는데 10초 정도 걸림        
        3. 그동안 시스템이 아무런 응답을 하지 않으면?! 사용자는 답답해 죽음     
        4. 그래서 시스템은 압축을 시작할 때 사용자에게 작업 중이라는 것을 알려줌</pre>
6. CPU 이용률과 처리량을 `최대화`하고 총처리 시간, 대기 시간, 응답 시간을 `최소화`하는 것이 바람직

## 스케줄링 알고리즘(Scheduling Algorithms)
### 선입 선처리 스케줄링(First-Come, First-Served Scheduling)
1. CPU를 `먼저` 요청하는 프로세스가 CPU를 할당받는 방식
2. 선입선출(FIFO) 큐를 이용해 쉽게 구현할 수 있음
    - 프로세스가 Ready Queue에 진입하면 해당 프로세스의 PCB를 큐의 끝(rear)에 연결
    - CPU가 쉬면, Ready Queue의 앞부분에 있는 프로세스에게 CPU 할당
    - 이후 해당 프로세스는 Ready Queue에서 제거됨
3. 평균 대기 시간이 굉장히 길어질 수 있음
    |프로세스|버스트 시간|
    |---|---|
    |P1|24|
    |P2|3|
    |P3|3|

    <pre>
    프로세스는 P1, P2, P3 순으로 도착한다고 가정하면       
    다음과 같은 Gantt 차트를 확인할 수 있음     
    <img src="./image/fifo_scheduling_chart_first.PNG" alt="fifo_scheduling_chart_first" width="500" style="max-width:100%"/>       
    프로세스 P1의 대기 시간: 0ms        
    프로세스 P2의 대기 시간: 24ms        
    프로세스 P3의 대기 시간: 27ms       
    평균 대기 시간: (0 + 24 + 27)/3 = 17ms

    하지만 프로세스가 P2, P3, P1 순으로 도착한다고 가정하면     
    다음과 같은 Gantt 차트를 확인할 수 있음     
    <img src="./image/fifo_scheduling_chart_second.PNG" alt="fifo_scheduling_chart_second" width="500" style="max-width:100%"/>     
    프로세스 P1의 대기 시간: 6ms        
    프로세스 P2의 대기 시간: 0ms        
    프로세스 P3의 대기 시간: 3ms       
    평균 대기 시간: (6 + 0 + 3)/3 = 3ms
    </pre>

    ➡ 프로세스의 도착 순서에 따라 평균 대기 시간이 크게 달라짐
4. 위의 첫번째 예시와 같이 `호위 효과(Convoy Effect)`가 발생할 수 있음      
    <pre>💡 호위 효과(Convoy Effect): 다른 프로세스들이 하나의 긴 프로세스가 CPU를 반환하기를 기다리는 것</pre>        
    ➡ CPU와 장치 이용률이 저하됨
5. `비선점형 방식`이라는 것을 명심!     
    ➡ 각 사용자가 규칙적인 간격으로 CPU를 할당받는 것이 중요한 `시분할 시스템`에서 특히 문제가 됨 