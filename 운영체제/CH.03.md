## 프로세스 개념
### 프로세스
1. 프로세스: 메모리에 적재 되어 `실행` 중인 프로그램 => `능동적`
    - 프로그램: 디스크에 저장되어 있는 명령어 리스트를 가진 파일(실행 파일이라고도 함) => `수동적`
2. 프로세스의 구조
    - 텍스트: 프로그램 코드
    - 스택: 함수 매개변수, 복귀 주소와 로컬 변수 같은 임시 자료
    - 데이터: 전역 변수
    - 힙: 실행 중에 동적으로 할당되는 메모리 (C의 malloc 같은) => 코드에서 동적으로 만들어지는 데이터

    <img src="./image/process_structure.PNG" alt="process_structure" width="400" style="max-width:100%"/>   

### 프로세스 상태(Process State)
프로세스는 실행되면서 상태가 변함

<img src="./image/process_state.PNG" alt="process_state" width="400" style="max-width:100%"/>

1. 새로운(new): 프로세스가 생성 중
2. 준비완료(ready): 프로세스가 메모리에 적재되고 Ready Queue에 들어와서 CPU 할당을 기다리는 중
3. 실행(running): CPU를 할당받아 명령어들이 실행 중     
    => CPU 스케줄러에 의해 Ready Queue에 있던 프로세스가 CPU 할당받음
4. 대기(waiting): 프로세스가 어떤 사건(입출력 완료 or 신호 수신 같은)이 일어나기를 기다림       
    => 직역하면 사건이 일어나기를 기다리는 상태이긴 한데 지금 수행되고 있는게 완료되기를 기다린다고 생각하면 됨
5. 종료(terminated): 프로세스 실행 종료     
- 단일 처리기에서는 하나의 프로세스만 실행될 수 있음      
- 많은 프로세스들이 준비완료 및 대기 상태에 있을 수 있음

### 프로세스 제어 블록(Process Control Block)
PCB는 운영체제가 프로세스를 표현한 것       
=> PCB에 프로세스에 대한 정보가 담겨있음
- PCB

    <img src="./image/process_control_block.PNG" alt="process_control_block" width="250" style="max-width:100%"/>
- PCB에 포함된 프로세스 정보
1. 프로세스 상태: new, ready, running, waiting, terminated 등
2. 프로세스 번호: 프로세스의 고유 번호
3. 프로그램 카운터(Program Counter, PC): 프로세스가 다음에 실행할 명령어의 주소를 가리킴
4. CPU 레지스터들 (레지스터 정보): 컴퓨터의 구조에 따라 다양한 수와 타입을 가짐     
    => 레지스터는 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터들과 상태 코드 정보 포함
5. CPU 스케줄링 정보: 프로세스 우선순위, 스케줄 큐에 대한 포인터와 다른 스케줄 매개변수 등 포함
6. 메모리 관리 정보: 메모리 위치 정보, 메모리 보호를 위해 사용하는 경계 레지스터와 한계 레지스터의 값 포함
    - 경계 레지스터: 사용자 영역에 존재하는 프로그램이 운영체제 영역을 침범하지 못하도록 함
    - 한계 레지스터: 각 사용자 프로그램이 다른 프로그램의 영역을 침범하지 못하도록 함
7. 회계(accounting) 정보: CPU 사용량과 실제 실행 시간, 프로세스 사용 시간 제한, 계정 번호, 프로세스 번호 등을 포함
8. 입출력 상태 정보: 프로세스에게 할당된 입출력 장치들과 열린 파일의 목록 등을 포함
- 한 프로세스에서 다른 프로세스로 CPU 전환되는 과정(context switching)

    <img src="./image/context_switching.PNG" alt="context_switching" width="400" style="max-width:100%"/>

## 프로세스 스케줄링
- 다중 프로그래밍: `항상` 프로세스가 실행되도록 하여 CPU 이용을 최대화함        
=> CPU 절대 못 쉬어, 노예처럼 일해라
- 시분할(Time-Sharing): 다중 프로그래밍을 논리적으로 확장한 개념, 프로세서가 다중 작업을 교대로 수행        
=> 각 프로그램에 일정한 프로세서 사용시간(Time Slice) 또는 Quantum을 할당해 사용자가 `주어진 시간` 동안 컴퓨터와 대화하는 형식으로 실행     
=> 프로세스들 사이에서 CPU를 빈번하게 교체      
=> 이를 위해 `프로세스 스케줄러`가 CPU에서 실행 가능한 프로세스들 중에서 하나를 선택
- 다중 프로그래밍과 시분할의 차이: 다중 프로그래밍은 CPU의 사용을 최대화하는 것이 목표, 시분할은 응답 시간을 최소화하는 것이 목표

### 스케줄링 큐(Scheduling Queues)
1. Job Queue: 시스템 내의 모든 프로세스들이 저장
2. Ready Queue: RAM에 적재되어 준비 완료(ready) 상태에 있는 프로세스들이 저장
3. Device Queue: 특정 입출력 장치(ex> 디스크)의 작업을 대기하는 프로세스들이 저장    
    - 각 장치는 자신의 Device Queue를 가짐
4. 프로세스 스케줄링 과정
    
    <img src="./image/queueing_graph.PNG" alt=" queueing_graph" width="450" style="max-width:100%"/>
   
    - 프로세스는 처음에 CPU를 할당받을(dispatch)때까지 Ready Queue에서 대기
    - 프로세스에 CPU 할당
    - CPU 할당받은 후 발생할 수 있는 일들
        1. 프로세스가 입출력 요청해서 입출력 큐(I/O Queue)에 들어감
        2. 프로세스에 할당된 시간이 초과됨
        3. 프로세스가 새로운 자식 프로세스 생성하고 자식 프로세스 종료 기다림
        4. 프로세스가 인터럽트에 의해 강제로 CPU 반환되고 Ready Queue에 놓일 수 있음


### 스케줄러
프로세스는 다양한 스케줄링 큐들 사이를 돌아다님     
운영체제는 큐에 있는 프로세스들 중 하나를 선택해야함        
=> 스케줄러란 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 모듈
1. 장기 스케줄러(또는 잡 스케줄러)
    - 디스크와 같은 저장 장치에 저장된 프로세스들을 선택해서 실행하기 위해 메모리에 적재
    - 실행 빈도수가 적음
    - 다중 프로그래밍 정도(메모리에 있는 프로세스들의 수)를 제어
    - 실행할 프로세스를 신중하게 선택해야 함
    - 장기 스케줄러는 입출력 중심과 CPU 중심 프로세스를 적절히 섞어서 선택해야 함
        1. 입출력 중심 프로세스: 연산보다 입출력 실행에 많은 시간을 소요
        2. CPU 중심 프로세스: 입출력보다 연산에 많은 시간을 소요
2. 단기 스케줄러(또는 CPU 스케줄러)
    - Ready Queue에 있는 프로세스 중 하나를 선택해 CPU 할당
    - CPU를 위해 `자주` 새로운 프로세스를 선택해야 함       
        => 속도가 매우 빨라야 함
3. 중기 스케줄러   
    - 너무 많은 프로세스가 메모리에 올라가지 않도록 메모리에서 프로세스를 제거
    - 차후에 다시 프로세스를 메모리로 불러와 중단 시점부터 실행 재개함 (스와핑(Swapping) 기법)  
        => 중기 스케줄러는 프로세스를 메모리에서 swap-out 시켰다가 다시 메모리로 swap-in 시킴

### 문맥 교환(Context Switch)
1. 프로세스가 실행되다 인터럽트가 발생해 운영체제가 개입하여 CPU에 할당된 프로세스를 바꾸는 것
2. 문맥 교환 과정
    - 현재 실행중인 프로세스의 상태(`문맥`)를 PCB에 저장
    - 다음에 실행할 프로세스의 상태를 레지스터에 적재해 작업 수행
2. 문맥 교환이 일어나는 동안 CPU는 아무런 작업도 하지 못하기 때문에 효율을 위해서 실행 시간을 최소화해야함

## 프로세스에 대한 연산
### 프로세스 생성
1. 프로세스는 트리 구조로 되어 있음     
    => 부모 프로세스가 자식 프로세스를 만듬 
2. PCB에 저장된 pid 값으로 프로세스 식별
3. 부모 프로세스가 자식 프로세스를 생성할 때, 자식 프로세스가 자원을 얻는 방법
    - 운영체제로부터 직접 자원을 얻음
    - 부모 프로세스가 가진 자원의 일부를 얻음       
        1. 자신의 자원을 분할해 자식들에게 나눠줌
        2. 자원을 자식이랑 같이 공유
4. 부모 프로세스가 자식 프로세스를 생성할 때, 프로세스들의 실행 방법
    - 부모 프로세스와 자식 프로세스가 동시에 실행된다
    - 부모가 일부 또는 모든 자식이 종료할 때까지 기다림
5. 주소 공간 측면에서 본 새로운 자식 프로세스
    - 자식 프로세스는 부모 프로세스의 복사본임      
        => 자식 프로세스는 부모와 똑같은 프로그램과 데이터를 가짐
    - 자식 프로세스가 자신에게 적재될 새로운 프로그램을 갖고 있음
6. 프로세스 생성 과정

    <img src="./image/process_create.PNG" alt=" process_create" width="600" style="max-width:100%"/>
    
    * fork(), exec(), wait(), exit() => 시스템 호출의 함수
    - fork() 함수 호출하면 부모 프로세스가 자신과 똑같은 자식 프로세스 생성       
        => 자식 프로세스는 부모 프로세스의 주소 공간의 복사본으로 구성되어 프로세스간 통신이 쉽게 이루어짐 
    - 이후 두 프로세스 중 한 프로세스가 exec() 함수 호출해 자신의 메모리 공간을 새로운 프로그램으로 교체     
        => 각자 수행하는 일이 달라짐
    - 부모 프로세스는 자식 프로세스가 실행되는 동안 할 일이 없으면 wait() 함수 호출 함        
        => 자식 프로세스 종료될 때까지 ready queue에서 자신을 제거하기 위해
    - 자식 프로세스 끝나면 exit() 함수 호출 해 종료시킴. 부모 프로세스는 wait() 함수 호출해 작업 마저 재개, 이후 exit() 호출해 종료

### 프로세스 종료
1. 프로세스 종료 과정
    - 프로세스가 exit() 함수 호출해 운영체제에게 자신의 삭제를 요청하면 종료됨
    - 이때, 프로세스는 wait() 함수 호출 통해 자신의 부모 프로세스에게 상태 값을 반환함
    - 종료되면 프로세스의 모든 자원이 운영체제로 반납됨
2. 부모 프로세스가 자식 프로세스를 종료하는 경우        
    => 종료하려면 자식 pid 알고 있어야 됨 (자식 생성될 때 자식의 identity 부모에게 전달됨)
    - 자식이 자신에게 할당된 자원을 초과해 사용할 때
    - 자식에게 할당된 태스크(task)가 더 이상 필요 없을 때
    - 부모가 exit를 하는데, 운영체제는 부모가 exit한 후에 자식이 계속 실행되는 것을 허용하지 않을 때        
        => 부모가 종료되면 운영체제가 자식들도 다 종료함 => `연쇄적 종료(cascading termination)`
3. 좀비 프로세스: 종료된 후 부모 프로세스가 wait() 함수 호출을 하지 않아 아직 정보가 반환되지 않은 상태의 프로세스
4. 고아 프로세스: 부모 프로세스가 먼저 종료된 프로세스      
    => Linux와 UNIX에서는 고아 프로세스의 새 부모 프로세스로 init(프로세스 트리의 루트 노드)를 지정

## 프로세스간 통신(Interprocess Communication, IPC)
1. 독립적인 프로세스: 시스템에서 실행 중인 다른 프로세스들에게 영향을 주거나 받지 않음      
    => 다른 프로세스와 데이터 공유하지 않음
2. 협력적인 프로세스: 시스템에서 실행 중인 다른 프로세스들에게 영향을 주거나 받음       
    => 다른 프로세스와 데이터 공유함
3. 프로세스간 통신이 필요한 이유
    - 정보 공유(Information Sharing): 여러 사용자가 동일한 정보를 필요로 할 수 있음         
        => 정보에 병행적으로 접근할 수 있어야 함
    - 계산 가속화(Computation Speedup): 특정 task를 빨리 계산하고 싶으면 subtask로 나눠 병렬로 실행해야 함      
        => 이를 위해선 여러 개의 CPU나 I/O 채널 등 처리 장치가 있어야 함
    - 모듈성(Modularity): 시스템 기능을 프로세스들 또는 스레드들로 나눠, 모듈식 형태의 시스템을 구성해야 할 수도 있음
    - 편의성(Convenience): 한 사용자가 동시에 많은 task를 수행할 수 있음        
        => 여러 task를 병렬로 수행해야 함
4. 협력적인 프로세스들은 프로세스간 통신(IPC)를 통해 정보 주고받음
5. IPC에는 두 가지 모델이 있음
    - 메시지 전달(Message Passing)
        
        <img src="./image/message_passing.PNG" alt=" message_passing" width="200" style="max-width:100%"/>
        
        1. 프로세스들은 메시지를 통해 정보 교환
        2. 충돌을 회피할 필요가 없기 때문에 적은 양의 데이터를 교환하는데 유용
        3. 분산 시스템에서 공유메모리 보다 구현하기 쉬움
        4. 시스템 호출을 통해 커널을 거쳐야하므로 시간이 조금 걸림
    - 공유 메모리(Shared Memory)

        <img src="./image/shared_memory.PNG" alt=" shared_memory" width="200" style="max-width:100%"/>
        
        1. 협력 프로세스들에 의해 공유 메모리 영역 구축됨
        2. 프로세스들은 공유 메모리를 통해 정보 교환
        3. 메모리 영역을 구축할 때만 시스템 호출이 필요함 => 평소에는 커널을 거치지 않기 때문에 메시지 전달보다 빠름
        4. 자원 충돌 문제를 처리해줘야 함       
    
        => 시스템의 코어 개수가 증가할수록 메시지 전달 방법의 성능이 더 좋음
6. 
    
    
    