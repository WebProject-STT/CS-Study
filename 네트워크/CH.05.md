## [CH5] HTTP 3

[Notion](https://www.notion.so/5-HTTP-3-a33b664b665f4382ad56a8bca3516fa0
)

```🙏  오늘 배울 내용 ```

    1. HTTP 버전 차이
    2. HTTP와 HTTPS
----------------------------
## **1. HTTP 버전 차이**

#### **[1] HTTP 0.9**
- 함수 : 유일하게 GET만 사용 가능
- 헤더 없음! => 오직 HTML 파일만 전송 가능
- 상태 확인(상태 코드) 존재하지 않는다.

#### **[2] HTTP 1.0**
- 모든 요청과 응답에 **헤더** 개념이 추가되었다.
    - 통신 응답 정보에 응답 결과(상태 코드)를 포함하기 시작 (200, 404 등)
    - 헤더의 'Content-Type'으로 HTML 파일 외 다른 문서들(이미지, CSS 등)도 전송이 가능해 졌다.
- 함수 : POST, HEAD가 추가되었다 => [GET, HEAD, POST 3가지 함수 사용]
- [Non-persistent Connection] Request 할때 마다 Connection을 새로 생성한다
<br>

    [📌 단점] : **성능 부하, 서버 부하**

#### **[3] HTTP 1.1**
- 함수 : OPTIONS, PUT, DELETE, TRACE 추가 => [GET, HEAD, POST, OPTIONS, PUT, DELETE, TRACE]

*  HTTP 1.0 버전보다 클라이언트-서버 간 요청/응답 시간 줄이려고 노력함 =  <span style="color:red">**[persistent Connection / Pipelining]**</span><br>
    ![persistent](./image/29.png)<br> 
            
    - [persistent Connection/Conncection 재사용] => 지정한 timeout 동안 커넥션을 닫지 않는 방식 👉 HTTP Request 시 Request 메세지 헤더 ```Connection : keep-alive``` 설정(사실  HTTP 1.1 버전에서는 Connection 헤더를 사용하지 않더라도, 이미 기본적으로 Persistent Conntection을 사용하도록 세팅되어 있다)
        * [🔔 장점] : CPU 메모리 자원 절약 및 네트워크 혼잡 줄임
        * [🔔 참고] : 지속 연결은 HTTP 1.0에도 지원한다 -> 차이점은? HTTP 1.1에서는 Keep-alive가 default로 들어 있어 따로 설정 X
        
            💡 만약 5개의 오브젝트를 가진 웹페이지가 있으면 ?<BR>
            [HTTP 1.0]
            클라이언트-서버 사이에서는 총 5번의 3-way handshake가 이루어진다 => 총 5번 연결을 끊었다가 다시 연결함<BR>
            [HTTP 1.1]
            클라이언트-서버 사이에서는 총 1번의 3-way handshake가 이루어진다 => 총 1번 연결을 끊었다가 다시 연결함
    
    ![Pipelining](./image/30.png)<br>

    - [Pipelining] => HTTP 1.0에서는 연결 한 번할때 **요청 한 번 + 응답 한 번**만 가능했다. 이와 달리 HTTP 1.1에서는 파이프라이닝으로 하나의 연결에 **다수의 요청 + 다수의 응답**이 가능해졌다.
        * [🔔 참고] : Pipeling이 가능해졌긴한데, HTTP 1.1은 기본적으로 Connection 한 개당 하나의 요청을 처리한다!
        * [🔔 장점] : 응답 속도 높여 네트워크 지연 감소 -> 페이지 뷰의 속도 빠르게 가능
        
<details>
<summary> HTTP 1.1의 단점 = 느리다 </summary>

![Pipelining 단점](./image/32.png)<br>

- HOL(Head of Line) Blocking - 파이프라인 문제점 (먼저 받은 요청이 끝나지 않으면 그 뒤에 있는 요청도 처리가 불가하다)
- RTT 증가 - HTTP/1.1의 경우 일반적으로 Connection 하나에 요청 한 개를 처리한다. 이렇다보니 매번 요청 별로 Connection을 만들게 되고 TCP 상에서 동작하는 HTTP의 특성상 3-way Handshake가 반복적으로 일어나며, 불필요한 RTT증가와 네트워크 지연을 초래하여 성능을 지연시킨다.
- 헤더가 크다 - 만약 연속적인 데이터 일때 쪼개져서 보내지는데 이 경우 매 요청시 마다 중복된 헤더 값을 전송하게 되며 각 도메인에 설정된 쿠키 정보도 매 요청시 마다 헤더에 포함되어 전송된다.
</details>
<BR>

##### HTTP 1.X에 대한 정리 그림

![QUIC 장점1](./image/HTTP1.X버전정리.png)
<BR>

#### **[4] HTTP 2.0**
* HTTP 1.1의 속도와 성능을 보완했다.
* (1) **바이너리 프레임과 멀티 플렉싱**
    * HTTP2의 핵심 = *바이너리 프레이밍 계층을 사용해 요청과 응답의 멀티플렉싱을 지원한다*
    * HTTP 1.1의 어느 부분을 개선시켰는가?<BR>
    👉 HTTP/1.1의 connection keep-alive, pipelining 개선시킴 <BR>

    1. 바이너리 포맷 인코딩 - 메세지, 레임<br>
        ![바이너리 포맷](./image/34.png)<br>
        * HTTP 1.X버전은 Plain Text(평문)를 사용하고, 개행으로 구별 했던것과 달리, HTTP 2.0은 HTTP 메시지를 바이너리 형태의 프레임(헤더-데이터)으로 나누고 이를 전송 후 받은 쪽에서 다시 조립한다 => 기계가 쉽게 파싱할 수 있다!
                
                [용어 설명]
                프레임 :  HTTP/2에서 통신의 최소 단위. 각 최소 단위에는 하나의 프레임 헤더가 포함된다. 
                            이 프레임 헤더는 최소한으로 프레임이 속하는 스트림을 식별한다. HEADERS Type Frame, DATA Type Frame이 존재한다.
                메시지: 다수의 프레임으로, 하나의 HTTP 요청/응답은 하나의 메세지에 해당된다.
                스트림: 양방향 통신을 통해 전달되는 한 개 이상의 메시지
                * 프레임이 여러개가 모여 메시지, 메시지가 여러개가 모여 스트림

    2. 멀티 플렉싱<BR>
        ![멀티 플렉싱2](./image/38.png)
        ![멀티 플렉싱1](./image/33.png)<br>
        * HTTP/1.1 까지는 한번에 하나의 파일만 전송이 가능했다(즉, 1개의 TCP연결에 1개의 스트림만 이용 가능하다 - 하나의 메세지가 응답될 때까지 다른 메시지를 요청하지 못한다). 이로인해 여러 파일을 전송 할 경우, 선행하는 파일의 전송이 늦어지면, 전체 파일 전송의 시간이 늘어나는 문제가 발생하였다. HTTP/2에서는 여러 파일을 한번에 병렬 전송하여, 이러한 문제를 해결했다.
        * 위의 이미지 처럼, 하나의 커넥션에서 여러 병렬 스트림(3개)이 존재 할 수 있다.즉, 여러 요청과 응답들을 병렬적으로 보내기가 가능해져 웹사이트 로딩이 빨라졌다. stream이 뒤섞여서 전송 될 경우, stream number를 이용해 수신측에서 조립하도록 설계했기 때문에 **멀티플렉싱**이 가능해진 것이다.
        * 즉 <u>HTTP 2.0은 패킷을 Frame 단위로 세분화하여 순서에 상관없이 수신한 쪽에서 조립하도록 설계해 **요청과 응답을 병렬**로 전달하고 하나의 Connection에서도 **여러 요청/응답을 처리(여러 스트림 사용)** 할 수 있게 되었다</u>
* (2) Stream 우선 순위<br>
    HTTP 2.0에서 메시지가 많은 개별 프레임으로 분할될 수 있고 여러 스트림의 프레임을 다중화(Multiplexing)할 수 있게 되면서, 스트림들의 우선순위를 지정할 필요가 생겼다. 클라이언트는 우선순위 지정을 위해 ‘우선순위 지정 트리'를 사용하여 서버의 스트림처리 우선순위를 지정할 수 있다. 서버는 우선순위가 높은 응답이 클라이언트에 우선적으로 처리한다.<br>
* (3) Header 압축 = HPACK<br>
    ![멀티 플렉싱2](./image/39.png)<br>
    HTTP 2.0은 Header의 정보를 압축하기 위해 Header Table과 Huffman Encoding 기법을 사용하여 처리한다. <br>
    위 그림처럼 만약 클라이언트가 2번 요청을 보낸다고 가정하면, HTTP 1.X의 경우에는 두개의 요청 Header의 중복 값이 존재하는데도 그냥 중복 전송한다. 하지만 HTTP 2.0경우에는 Header에 중복값이 존재할 경우 Header Table을 사용하여 중복 Header를 검출하고, 중복된 Header는 **index값**만 전송하고 중복되지 않은 Header의 값은 Huffman Encoding 기법으로 인코딩 처리하여 전송한다.
    <details>
    <summary> Huffman encoding </summary>
    
    * Huffman 코딩이란?
        데이터 문자의 등장 **빈도수**에 따라 다른 길이의 부호를 부여합니다.
        [주의!] 허프만 코딩은 각 문자에 부여된 이진 코드가 접두부가 되지 않도록 한다!
    * Encoding 과정<BR>
        [ex] AAABRBACARD => 00010010110001100101111(23비트)<BR>
        1. 각 문자의 등장 빈도수를 측정한다.
        2. 측정한 빈도수를 기준으로 정렬한다.
        3. 가장 작은 빈도수를 가진 2가지 문자를 같은 부모 노드를 가진 서브트리로 만든다(이때, 부모노드에는 자식 노드의 빈도수의 합을 저장한다)
        4. 이 과정을 하나의 트리가 남을때지 반복한다.
        5. 만들어진 트리에서 ROOT부터 왼쪽 자식노드는 '0'을 오른쪽 자식 노드는 '1'을 부여하여 각 문자를 인코딩한다.
        ![Encodingh](./image/40.png)<br>
    * Decoding 과정<br>
        디코딩은 인코딩해서 나온 00010010110001100101111(23비트)에서 ROOT부터 시작하여 Leaf 노드를 찾을때까지 반복하여 문자열을 얻습니다.
    </details>

* (4) Server Push<br>
    ![Server Push](./image/35.png)<br>
    서버에서 클라이언트에서 요청하지 않은 리소스를 전송할 수 있다. <br>
        
            🔔 예를 들어서 클라이언트에서 HTML을 요청했고, 서버가 css, image.. 등 여러 리소스가 포함되어있는 HTML를 전송한다면 ??

            [HTTP 1.1 경우]
            클라이언트는 요청한 HTML 문서를 수신 후 해당 문서를 해석한 다음 필요한 리소스를 재 요청한다.
            [HTTP 2.0 경우]
            Server Push 기법을 통해, 클라이언트가 요청하지 않았지만 필요한 리소스(HTML 문서에 포함된 리소스)를 PUSH한다.
    
    * 이 방법을 통해 클라이언트의 요청을 최소화 해서 성능 향상을 이끌어 낸다.

* [🔔 결론] HTTP 2.0의 모든 통신은 **단일 TCP**연결을 통해 이뤄진다.

<br>

##### HTTP 2.0 버전 정리

![HTTP 1.1 버전 정리](https://freecontent.manning.com/wp-content/uploads/HTTP-vs-with-Push-HTTP1.gif)
![HTTP 2.0 버전 정리](https://freecontent.manning.com/wp-content/uploads/HTTP-vs-with-Push-HTTP2.gif)
![HTTP 2.0 서버 푸시](https://freecontent.manning.com/wp-content/uploads/HTTP-vs-with-Push-HTTP2push.gif)

<br>

#### **[5] HTTP 3.0**
![HTTP 3.0](./image/41.png)<br>
* HTTP3는 HTTP 버전 1 ~ 2와 달리 기반 프로토콜을 **UDP 프로토콜**로 사용한다. 정확하게는 UDP 기반으로 하는 **QUIC**를 사용한다. UDP를 사용한다고 해서 기존의 신뢰성 있는 통신을 버리는 것이 아니다.

##### **QUIC(Quick UDP Internet Connections)** 이란?
* QUIC이 생기게 된 배경

    ![TCP](./image/42.png)<br>

    TCP의 신뢰성 있는 통신을 위해서는 시간이 오래 걸린다.<BR>
    👉 3 Way Handshake, 4 Way Handshake, Sequence number
<BR>

*  QUIC은 TCP가 가지고 있는 위와 같은 문제들을 해결하고자 구글이 개발한 UDP 기반의 프로토콜이다.

* 그렇다면 왜 TCP가 아닌 UDP일까?
    * TCP의 단점<BR>
        ![TCP 단점1](./image/43.png)<br>
        ![TCP 단점2](./image/44.png)<br>
        => TCP의 경우 헤더에서 보다시피 많은 기능이 포함된 프로토콜로 실질적으로 사용자가 커스텀 기능을 구현할 자리가 없다
        => UDP의 경우 헤더의 공간이 많이 있기 때문에 커스텀 기능을 구현하기 쉽다. 즉, UDP의 이 공간을 잘 활용하면 TCP와 비슷한 수준의 신뢰성을 제공할 수도 있다는 것이다.

        🎇 레이턴시를 줄이려면 프로토콜 외적인 것들을 건들여야한다. 그러므로 기존의 TCP를 수정하기 어렵다. 반면 UDP를 사용하면 QUIC의 기능을 확장하기 쉽다. 그래서 QUIC에서는 UDP를 기반으로 하는 것이다.

* QUIC의 장점
    1. Connection 설정 시 레이턴시 감소

        ![QUIC 장점1](./image/45.png)<br>
        - QUIC는 TCP를 사용하지 않기 때문에 3 Way handshake과정을 거치지 않아도 된다
        - 즉, 일반 TCP는 연결 설정하는데 기본적으로 **1 RTT**가 필요하다.
            <details>
            <summary> RTT란 </summary>

            *RTT란? 클라이언트가 보낸 요청을 서버가 처리한 후, 다시 클라이언트로 응답해주는 사이클
            </details>
        - 이 TCP연결에 TLS를 사용한 암호화까지 고려하게 된다면, TLS의 자체 핸드쉐이크까지 더해져 총 **3 RTT**가 필요하다.
        - 반면 QUIC는 첫 연결 설정에 **1 RTT**만 소요된다. 즉, 연결하는 속도가 확 줄어든다. 
            * 그렇다면 QUIC에서 어떻게 이것을 가능하게 했는가?<BR>
                📝 바로 첫번째 handshake를 거칠 때, 연결 설정에 필요한 정보 + 데이터를 보내는 것이다. 원래 TCP+TLS 경우에는 데이터를 보내기 전에 신뢰성 있는 연결과 암호화에 필요한 모든 정보를 교환하고 유효성을 검사한 뒤 데이터를 교환한다. 이와 달리 QUIC는 묻지도 따지지 않고 그냥 바로 데이터를 보낸다.
                * 그러면 보안에 문제는 ?!<BR>
                    📝 QUIC에서 암호화를 안하는 것이 아니다. QUIC은 클라이언트가 서버로 첫 요청을 보낼 때는 서버의 세션 키를 모르는 상태이다. 이 때문에 목적지인 서버의 Connection ID를 사용해 생성한 특별한 키 **초기화 키(initail key)** 를 이용해 통신을 암호화하는 것이다. <bR>
                    📝 그리고 한 번 연결에 성공했다면 서버는 이 설정을 **캐싱**해 두었다가 다음 연결 때 새로운 연결이 아닌 캐싱해둔 설정을 사용해 바로 연결시키기 때문에 **0 RTT**만으로 바로 통신이 가능하다.<br>
                    🎇 즉, <u>QUIC는 **1 RTT**와 **O RTT**를 필요로 한 것이다</u>
    2. HTTP 2.0 버전과 같이 멀티플렉싱을 지원한다.
        * 멀티플렉싱의 장점은 여러 개의 스트림을 사용해, 그 중 특정 스트림의 패킷이 손실되었다 해도 해당 스트림만 영향을 미치기 때문에 나머지 스트림은 그대로 사용할 수 있다.
    3. 클라이언트의 IP가 바뀌어도 연결이 유지됨
        * 요즘같이 Wifi를 사용하게 되면 클라이언트의 IP가 자주 변경된다. TCP의 경우 [출발지의 IP주소+PORT, 도착지의 IP주소+PORT]로 연결을 식별하기 때문에 IP가 변경되면 연결이 끊어져 버린다. 연결이 끊어졌기 때문에 다시 3 Way handshake를 겪어야 되서 시간이 오래 걸린다. 
        * QUIC는 Connection ID를 사용해 서버와 연결하기 때문에 클라이언트 IP와 비관한 데이터이다. 그러므로 클라이언트가 IP를 변경하더라도 3 Way handshake를 생략할 수 있어 시간이 절약된다.
    4. 패킷 손실 감지에 걸리는 시간 단축
        * QUIC도 TCP와 마찬가지로 전송하는 패킷에 대한 흐름 제어를 한다 => QUIC와 TCP 모두 ARQ를 사용하는 프로토콜이기 때문이다. <br>
            🎇 ARQ 방식 =  에러가 발생하면 재전송을 통해 에러를 복구하는 방식
        * TCP = Stop and Wait ARQ 방식(송신 측이 패킷을 보낸 후 타이머를 사용해 일정 시간이 경과해도 수신측에서 답변이 안오면 패킷이 손실된것으로 추정해 해당 패킷을 다시 보내는 방식)<BR>
            🔔 TCP 패킷 손실 감지의 대표적인 문제 : 타임 아웃의 시간 지정(동적 계산) -> 타임아웃이 발생해서 패킷 손실이 발생하게 되면 RTT 계산 애매해짐
                
                (EX) 패킷 전송 -> 타임 아웃 -> 패킷 재전송 -> ACK 받음
                
                1. 근데 이거 첫 번째로 보낸 패킷 ACK야?
                2. 두 번째로 보낸 패킷 ACK야?

                => 이 ACK의 주인을 아려면 타임스탬프를 패킷에 찍어 주는 등 별도의 방법 사용 + 패킷 검사 = 재전송 모호성 발생
        * QUIC = TCP의 문제점을 해결하고자 헤더에 별도의 **패킷 번호 공간** 부여함. 이 패킷 번호는 패킷의 전송 순서 자체만을 나타내며, 재전송시 동일한 번호가 전송되는 시퀀스 번호와는 다르게 매 전송마다 모노토닉하게 패킷 번호가 증가하기 때문에, 패킷의 전송 순서를 명확하게 파악할 수 있다.

--------------------------------
## **2. HTTP와 HTTPS**

### **HTTP란?**
``` 웹 브라우저와 웹 서버가 통신하기 위한 프로토콜 ```
* HTTP의 문제점은?
    * 서버에서 브라우저로 전송되는 정보가 암호화되어 있지 않아(평문 통신), **도청**이 가능하고 **변조**가 가능하다. 또한, 통신 상대를 특정하지 않기 때문에 **위장**이 가능하다. 

### **HTTPS(HTTP over Secure Socket Layer)**
### **HTTPS란(PORT-443)?**

![HTTPS](./image/36.png)<br>

``` HTTP의 문제점인 보안을 방지한 프로토콜로, HTTP에 **SSL/TLS**기반의 Secure Socket을 활용한 프로토콜 ```

``` 웹 브라우저와 웹 서버가 각각 키를 가지며 그 키를 통해 암호화/복호화하여 HTTP통신을 하기 때문에 클라이언트와 서버만이 데이터를 열람 가능 ```

* [🔔 참고] : TLS(Transport Layer Security)는 과거 SSL에서 이름이 변경 된 것이다. 하지만 아직도 SSL이란 명칭이 많이 사용되고 있다.
* [🔔 참고] : SSL을 참고하여 표준화된 것이 TLS이므로 이 둘은 본질적으로 같은 기능과 용도를 가졌기 때문에 붙여서 사용한다.
* [🔔 질문] : HTTPS = SSL/TLS 인가 ? (맞다면 왜? 아니라면 왜?)
    <details>
    <summary> 질문 정답 </summary>

    * 정답 = 아니다!
    * SSL/TLS는 보안 통신을 위한 보안용 프로토콜이다.
    * HTTPS는 이런 보안용 프로토콜 SSL/TLS 위에 HTTP를 올려 보안된 HTTP 통신을 하는 프로토콜이다.
    * 즉 HTTPS = HTTP + SSL/TLS라 해야 정답이다. 
    </details>

* 모든 웹 사이트가 HTTPS를 사용하지 않나요?

        쉽게 말하면, ‘모든 사이트가 다 HTTPS가 되면 좋겠네?’라고 말할 수도 있는데, 서버에 과부하가 걸릴 수 있다.
        웹서핑을 하는데, 모든 사이트에서 텍스트를 암호화하여 주고 받으면, 속도가 현저하게 느려진다. 
        따라서, 중요한 사이트에서는 HTTPS로 관리하고, 그렇지 않은 사이트에서는 HTTP로 세팅한다.

* HTTPS의 암호화 원리 = **공개키(비 대칭키) 암호화** 방식

    ![HTTPS](./image/공개키1.png)<br>

    * 공개키 = 암호화, 복호화 시킬 수 있는 서로 다른 2개의 키가 존재하는데, 이 두 개 키 중 1번으로 암호화하면 2번으로 복호화 OR 2번으로 암호화하면 1번으로 복호화하는 룰이 있다.
    * 이 둘 키 중 하나의 키는 모두에게 공개하는 공개키(1번 키)로 만들어서 공개키 저장소에 등록한다. 서버는 서버만 알 수 있는 개인키(2번 키)를 소유하고 있으면 된다.
    * 그러면 1번 키로 암호화된 HTTP 요청 (HTTPS) 요청이 들어오면, 서버는 개인키(2번 키)를 이용해 1번 키로 암호화된 문장을 해독한다. 서버는 요청이 무엇인지 알게 되고 요청에 알맞는 응답을 다시 개인 키(2번 키)로 암호화 해 요청한 클라이이언트에게 응답을 전달한다. 그리고 응답을 받은 클라이언트는 공개 키(1번 키)를 이용해 개인 키(2번 키)로 암호화된 HTTPS 응답을 해독하고 사용한다.

    * [🔔 참고] 하지만 공개키만 사용해서 통신하면 지연에 문제가 생겨 좋지 않다. 따라서 대칭키(하나의 키로 암/복호화를 모두 하는 방식)과 혼합하여 사용한다.

* TLS(SSL) 란?<BR>
    ![HTTPS](./image/TLS.png)<br>
    * **TLS (Transport Layer Security) - 전송 계층의 통신에 보안 기능을 추가하기 위한 기능** => handshake을 통해 양쪽에 대칭 키를 생성하고, 전송하는 데이터를 대칭 키로 암호화함<BR>
        => SSL(Secure Sockets Layer)

    * 인증서(Digital certificate, Public key certificate -> 공개 키)
        * **공개 키의 소유권**을 인증하는 전자 문서
        * 소유자의 정보와 발행자의 디지털 서명을 포함하고 있음
        * 일반적으로 CA가 발행함
    
    * 인증 기관 = CA(Certificate authority)
        * **인증서의 신뢰성**을 보장하기 위한 기업
        * 인증서를 발행하는 기관이므로, CA를 신뢰할 수 있어야 인증서를 신뢰할 수 있음 -> 인증기관으로부터 공인인증서를 발급받아 서버에 설치해야 HTTPS 통신 가능
        * 인증기관에 공개 키와 개인 키 설정
            1. 웹 서비스 제공자(A)는 자신의 공개 키+개인 키를 생성하고, **공개 키**를 인증기관에 보냄
            2. CA기업의 이름과 웹 서버(A)의 공개키, 공개키의 암호화 방법 등의 정보를 담은 인증서를 만들고, 해당 인증서를 CA 기업의 **개인키**로 암호화해서 만든 인증서를 A서버에게 제공
            3. 웹 서버(A)는 인증서와 개인키를 가지게 되어 HTTPS 통신을 할 수 있게 됨 => A서버의 공개키로 암호화된 HTTPS 요청이 아닌 요청이 오면 이 암호화된 인증서를 클라이언트에게 줌
            4. 클라이언트에는 여러 인증기관의 공개키와 인증서가 이미 설치되어 있음 => 웹 서버(A)와 통신 시, 인증기관의 개인키로 서명된 인증서를 클라이언트가 받으면 인증기관의 공개키로 복호화 가능 
                * (EX) 클라이언트에서 웹 서버(A)로 Index.html 파일 요청 -> HTTPS 요청이 아니기 때문에 CA기업이 A서버의 정보를 CA 기업의 개인키로 암호화한 인증서를 받음. <BR>
                📝 여기서 중요한 점!! <BR>
                    세계적으로 신뢰할 수 있는 CA 기업의 공개키는 브라우저가 이미 알고 있다 => 그러므로 브라우저가 CA 기업 리스트를 쭉 탐색하면서 인증서에 적힌 CA 기업의 개인 키를 이미 알고 있는 공개 키로 해독해서 웹 서버(A)의 공개 키를 얻음!<BR>
                    그리고 나서 웹 서버(A)와 통신 시 얻은 공개 키를 암호화해서 요청을 날리게 된다.<BR>
                    📝 참고로, HTTPS를 지원한다고 해서 무조건 안전한 것은 아니다. 왜냐하면 신뢰할 수 있는 CA 기업이 아니라 자체적으로 인증서를 발급할 수도 있고, 신뢰할 수 없는 CA 기업을 통해서 인증서를 발급받을 수도 있기 때문이다 => 그래도 이런 기업은 "주의 요함", "안전하지 않은 사이트" 등 알림을 주기 때문에 적절히 피해갈 수 있음
    
    * TLS 동작 방식

        ![TLS 동작 방식](./image/TLS동작.png)<br>
        🧳 - 웹 서버 / 💻 - 클라이언트

        [💻 - 클라이언트] <BR>
        * Client Hello - 클라이언트가 서버로 연결을 시작하는 메시지를 보내며, 이때 지원 가능한 TLS 버전과 암호화 방식들을 포함함 => handshaking 시작

            [종류]
            
            * random : 32바이트 난수 값 -> 나중에 비밀 데이터(master secret)를 위해 사용
            * Session ID : 세션을 처음 생성할 때는 빈 값. 이미 생성된 세션이 있다면 그 세션 ID를 전달
            * Cipher suite : 클라이언트가 지원 가능한 키 교환 알고리즘+대칭키 암호 알고리즘+해시 알고리즘 3가지 정보에 대해 보내줌

        [🧳 - 웹 서버] <BR>
        * Server Hello - 사용할 TLS버전, 클라이트, 서버 공통으로 지원가능한 최적의 Cihper suite, 압축 방식 등을 client에게 전달(서버는 클라이언트가 보낸 Cipher suite - 알고리즘 중 최적의 알고리즘을 선택해서 사용)

            - random : server도 32바이트 난수를 생성해서 client에게 전달, 나중에 master secret이라는 비밀값을 생성할때 사용됨
        * Server certificate - 서버가 인증서(Certificate)를 보냄(인증서: 인증기관의 개인키로 암호화된 사이트의 정보와 공개키가 있음 -> 별도의 인증기관에서 받은 것으로 서버가 신뢰성 있다는 것을 의미)
        * Server hello done - 서버의 인사 끝남

        [💻 - 클라이언트] <BR>
            + 가장 먼저 서버에서 받은 인증서를 검증

        * Client key exchange - 키교환에 필요한 정보(pre-master secret를 서버에 제공
        
                pre-master secret : 이전에 서버에거 받은 random 값 + 클라이언트가 만든 random 값 조합 & 암호화(암호화는 서버에서 받은 인증서 안 서버의 공개키를 이용함)

            🔔 서버가 암호화된 pre-master secret을 받으면, 자신의 개인 키로 복화해서 pre-master secret 값 얻는다. 이렇게 되면 서로가 pre-master secret을 공유하게 된다. 서버와 클라이언트는 이 master secret으로 세션에 사용될 키(대칭키)를 생성하게 된다. 이 세션키를 가지고 앞으로 암호화 통신에 사용하게 된다.
        * Change cipher spec - 클라이언트는 서버에게 이제 Session 키를 생성하고 이걸로 암호화하여 보내겠다고 알림

        * Finished - 클라이언트 handshaking 끝냄

        [🧳 - 웹 서버] <BR>
        * Change cipher spec - 서버는 클라이언트에게 이제 Session 키를 생성하고 이걸로 암호화하여 보내겠다고 알림

        * Finished - 서버 handshaking 끝냄


        * 이제 주고받은 비밀키(세션 키)를 통해 안전하게 통신한다.
